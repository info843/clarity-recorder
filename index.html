<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Clarity Interview Recorder</title>
  <style>
    body { font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; padding:16px }
    video { width:100%; max-width:720px; background:#000; border-radius:12px }
    button { padding:10px 14px; border-radius:8px; border:1px solid #d1d5db; background:#fff; cursor:pointer; margin-right:8px }
    #status { margin:8px 0; white-space:pre-wrap }
  </style>
</head>
<body>
  <h1>Interview Recorder</h1>
  <div>
    <button id="start">üéô Aufnahme starten</button>
    <button id="stop" disabled>‚èπ Stop</button>
    <button id="upload" disabled>‚¨Ü Upload</button>
  </div>
  <div id="status">Bereit.</div>
  <video id="preview" autoplay muted playsinline></video>
  <video id="playback" controls style="display:none;margin-top:8px"></video>

<script>
let stream, rec, chunks = [], blob;

const qs = new URLSearchParams(location.search);
// Hier kommen sp√§ter echte Werte aus Wix/iframe rein:
const uid       = qs.get('uid')       || 'TEST-UID';
const companyId = qs.get('companyId') || 'TEST-COMPANY';
// F√ºr Audio-only einfach video:false setzen:
const mediaConstraints = { video: true, audio: true };

function status(t){ document.getElementById('status').textContent = t; }
function enable(id, on){ document.getElementById(id).disabled = !on; }

document.getElementById('start').onclick = async () => {
  try {
    stream = await navigator.mediaDevices.getUserMedia(mediaConstraints);
    document.getElementById('preview').srcObject = stream;
    chunks = []; blob = null;
    rec = new MediaRecorder(stream);
    rec.ondataavailable = e => e.data?.size && chunks.push(e.data);
    rec.onstop = () => {
      blob = new Blob(chunks, { type: rec.mimeType || 'video/webm' });
      const pb = document.getElementById('playback');
      pb.src = URL.createObjectURL(blob);
      pb.style.display = 'block';
      status(`Fertig: ${(blob.size/1024/1024).toFixed(1)} MB`);
      enable('upload', true);
    };
    rec.start(1000);
    status('üî¥ Aufnahme l√§uft‚Ä¶');
    enable('start', false);
    enable('stop', true);
  } catch (e) {
    status('‚ùå Start fehlgeschlagen: ' + (e.message || e));
  }
};

document.getElementById('stop').onclick = () => {
  try { if (rec && rec.state !== 'inactive') rec.stop(); } catch {}
  try { if (stream) stream.getTracks().forEach(t => t.stop()); } catch {}
  enable('stop', false);
};

document.getElementById('upload').onclick = async () => {
  try {
    if (!blob) { status('Keine Aufnahme vorhanden.'); return; }
    status('Upload vorbereiten‚Ä¶');

    // 1) Upload-URL vom Server holen
    const prepRes = await fetch('/api/mux-upload', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ uid, companyId })
    });

    const prepText = await prepRes.text();
    let prep;
    try { prep = JSON.parse(prepText); }
    catch { throw new Error('Server antwortete nicht mit JSON: ' + prepText.slice(0, 200)); }

    if (!prepRes.ok || prep?.error) {
      throw new Error('Server-Fehler: ' + (prep?.error || prepText));
    }
    if (!prep.uploadUrl) throw new Error('Keine uploadUrl erhalten.');

    // 2) Direkt zu Mux hochladen
    status('Lade hoch‚Ä¶');
    const up = await fetch(prep.uploadUrl, {
      method: 'PUT',
      // kein Content-Type setzen ‚Äì Mux akzeptiert raw Bytes
      body: blob
    });

    if (!up.ok) {
      const errText = await up.text().catch(()=> '');
      throw new Error('Upload fehlgeschlagen (' + up.status + '): ' + errText.slice(0, 200));
    }

    status('‚úÖ Upload abgeschlossen, Mux transcodiert nun‚Ä¶');
    // Optional: ans Parent-Fenster (Wix) melden
    window.parent?.postMessage(
      { type: 'RECORD_UPLOADED', provider: 'mux', uploadId: prep.uploadId, uid, companyId },
      '*'
    );
  } catch (e) {
    status('‚ùå ' + (e.message || e));
  }
};
</script>
</body>
</html>
