<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interview Recorder</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;padding:16px}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:16px;align-items:start}
    video, mux-player{width:100%;max-width:100%;background:#000;border-radius:12px}
    button{padding:10px 14px;border-radius:8px;border:1px solid #d1d5db;background:#fff;cursor:pointer;margin-right:8px}
    #status{margin:12px 0}
  </style>
  <!-- Mux Player (Web Component) -->
  <script defer src="https://cdn.jsdelivr.net/npm/@mux/mux-player"></script>
</head>
<body>
  <h1>Interview Recorder</h1>

  <div>
    <button id="start">üéô Aufnahme starten</button>
    <button id="stop" disabled>‚èπ Stop</button>
    <button id="upload" disabled>‚¨Ü Upload</button>
  </div>

  <div id="status">Bereit.</div>

  <div class="row">
    <!-- Linke Seite: Live Preview / Aufnahme -->
    <video id="preview" autoplay muted playsinline></video>

    <!-- Rechte Seite: Playback (Mux Player, erst sichtbar wenn ready) -->
    <mux-player id="mux" style="display:none" stream-type="on-demand"
      primary-color="#2563eb" secondary-color="#111827" muted="false"
      playsinline></mux-player>
  </div>

<script>
let stream, rec, chunks=[], blob;
let lastUploadId = null;
let pollTimer = null;

const qs = new URLSearchParams(location.search);
const uid = qs.get('uid') || 'TEST-UID';
const companyId = qs.get('companyId') || 'TEST-COMPANY';
const mode = (qs.get('mode') || 'video').toLowerCase(); // 'video' | 'audio'

function status(t){ document.getElementById('status').textContent = t; }

async function startCapture() {
  const constraints = (mode === 'audio')
    ? { audio: true, video: false }
    : { audio: true, video: true };

  stream = await navigator.mediaDevices.getUserMedia(constraints);
  const prev = document.getElementById('preview');
  prev.srcObject = stream;
  prev.style.display = (mode === 'audio') ? 'none' : 'block';

  chunks=[]; blob=null;
  rec = new MediaRecorder(stream);
  rec.ondataavailable = e => e.data?.size && chunks.push(e.data);
  rec.onstop = () => {
    blob = new Blob(chunks, { type: rec.mimeType || (mode==='audio' ? 'audio/webm' : 'video/webm') });
    status(`Fertig: ${(blob.size/1024/1024).toFixed(1)} MB`);
    document.getElementById('upload').disabled = false;
  };
  rec.start(1000);
  status('üî¥ Aufnahme l√§uft‚Ä¶');
  document.getElementById('start').disabled = true;
  document.getElementById('stop').disabled = false;
}

document.getElementById('start').onclick = async () => {
  try { await startCapture(); }
  catch(e){ status('‚ùå Start fehlgeschlagen: ' + (e.message||e)); }
};

document.getElementById('stop').onclick = () => {
  try{ if(rec && rec.state!=='inactive') rec.stop(); }catch{}
  try{ if(stream) stream.getTracks().forEach(t=>t.stop()); }catch{}
  document.getElementById('stop').disabled = true;
};

document.getElementById('upload').onclick = async () => {
  try{
    if(!blob){ status('Keine Aufnahme vorhanden.'); return; }
    status('Upload vorbereiten‚Ä¶');

    // 1) Upload-URL vom Server holen
    const res = await fetch('/api/mux-upload', {
      method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ uid, companyId })
    });

    // Fehler robust auslesen
    const text = await res.text();
    let data = {};
    try { data = text ? JSON.parse(text) : {}; } catch { data = { error: 'Invalid JSON from server', raw: text }; }
    if (!res.ok || data.error || !data.uploadUrl) {
      status('‚ùå Server-Fehler: ' + (data.error || res.status));
      return;
    }

    // 2) Direkt-Upload zu Mux
    status('Lade hoch‚Ä¶');
    const up = await fetch(data.uploadUrl, { method:'PUT', body: blob });
    if(!up.ok) throw new Error('Upload fehlgeschlagen: ' + up.status);

    status('‚úÖ Upload abgeschlossen ‚Äî Status wird abgefragt‚Ä¶');
    lastUploadId = data.uploadId;

    // 3) Status sofort abfragen und anzeigen
    await showMuxStatusOnce();

    // 4) Wenn noch nicht 'ready', alle 5s pollen
    if (pollTimer) clearInterval(pollTimer);
    pollTimer = setInterval(showMuxStatusOnce, 5000);

  } catch(e){
    status('‚ùå ' + (e.message||e));
  }
};

async function showMuxStatusOnce(){
  if (!lastUploadId) return;

  const r = await fetch(`/api/mux-asset?uploadId=${encodeURIComponent(lastUploadId)}`);
  const j = await r.json();

  // j: { uploadId, uploadStatus, assetId, assetStatus, playbackId }
  const info = [
    `Upload: ${j.uploadStatus || 'n/a'}`,
    `Asset: ${j.assetStatus || 'n/a'}`,
    j.assetId ? `AssetId: ${j.assetId}` : null,
    j.playbackId ? `PlaybackId: ${j.playbackId}` : null
  ].filter(Boolean).join(' ‚Äî ');

  status(`‚úÖ Upload abgeschlossen ‚Äî ${info}`);

  // Wenn ready + playbackId ‚Üí Mux Player zeigen
  if (j.assetStatus === 'ready' && j.playbackId) {
    if (pollTimer) { clearInterval(pollTimer); pollTimer = null; }
    const mux = document.getElementById('mux');
    mux.playbackId = j.playbackId;
    mux.style.display = 'block';
  }
}
</script>
</body>
</html>
