<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Clarity Interview Recorder</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;padding:16px}
    video{width:100%;max-width:720px;background:#000;border-radius:12px}
    button{padding:10px 14px;border-radius:8px;border:1px solid #d1d5db;background:#fff;cursor:pointer;margin-right:8px}
    #status{margin:8px 0}
  </style>
</head>
<body>
  <h1>Interview Recorder</h1>
  <div>
    <button id="btnStart">üéô Aufnahme starten</button>
    <button id="btnStop" disabled>‚èπ Stop</button>
    <button id="btnUpload" disabled>‚¨Ü Upload</button>
  </div>
  <div id="status">Bereit.</div>
  <video id="preview" autoplay muted playsinline></video>
  <video id="playback" controls style="display:none;margin-top:8px"></video>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const el = (id) => document.getElementById(id);
  const $start = el('btnStart');
  const $stop = el('btnStop');
  const $upload = el('btnUpload');
  const $status = el('status');
  const $preview = el('preview');
  const $playback = el('playback');

  let stream, rec, chunks = [], blob;

  const qs = new URLSearchParams(location.search);
  const uid = qs.get('uid') || 'TEST-UID';
  const companyId = qs.get('companyId') || 'TEST-COMPANY';

  const setStatus = (t) => { $status.textContent = t; };

  async function startRecording() {
    try {
      stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      $preview.srcObject = stream;
      chunks = []; blob = null;

      rec = new MediaRecorder(stream);
      rec.ondataavailable = (e) => e.data && e.data.size && chunks.push(e.data);
      rec.onstop = () => {
        blob = new Blob(chunks, { type: rec.mimeType || 'video/webm' });
        $playback.src = URL.createObjectURL(blob);
        $playback.style.display = 'block';
        setStatus(`Fertig: ${(blob.size/1024/1024).toFixed(1)} MB`);
        $upload.disabled = false;
      };
      rec.start(1000);

      setStatus('üî¥ Aufnahme l√§uft‚Ä¶');
      $start.disabled = true;
      $stop.disabled = false;
    } catch (e) {
      setStatus('‚ùå Start fehlgeschlagen: ' + (e?.message || e));
    }
  }

  function stopRecording() {
    try { if (rec && rec.state !== 'inactive') rec.stop(); } catch {}
    try { if (stream) stream.getTracks().forEach(t => t.stop()); } catch {}
    $stop.disabled = true;
  }

  async function uploadRecording() {
    try {
      if (!blob) { setStatus('Keine Aufnahme vorhanden.'); return; }
      setStatus('Upload vorbereiten‚Ä¶');

      const res = await fetch('/api/mux-upload', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ uid, companyId })
      });

      // robuster Fehlertext
      if (!res.ok) {
        const txt = await res.text();
        let msg = txt;
        try { const j = JSON.parse(txt); msg = j.error || JSON.stringify(j); } catch {}
        throw new Error(`Server-Fehler: ${msg}`);
      }

      const { uploadUrl, uploadId } = await res.json();
      if (!uploadUrl) throw new Error('Server lieferte keine uploadUrl');

      setStatus('Lade hoch‚Ä¶');
      const up = await fetch(uploadUrl, { method: 'PUT', body: blob });
      if (!up.ok) {
        const t = await up.text().catch(()=> '');
        throw new Error('Upload fehlgeschlagen: ' + t);
      }

      setStatus('‚úÖ Upload abgeschlossen, wird transcodiert‚Ä¶');
      window.parent?.postMessage(
        { type: 'REC_DONE', provider: 'mux', uploadId, uid, companyId },
        '*'
      );
    } catch (e) {
      setStatus('‚ùå ' + (e?.message || e));
    }
  }

  $start.onclick = startRecording;
  $stop.onclick = stopRecording;
  $upload.onclick = uploadRecording;
});
</script>
</body>
</html>
