<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Clarity Glass Orb Avatar</title>
<style>
  /* Volltransparentes Dokument */
  html,body{margin:0;height:100%;background:transparent;overflow:hidden}
  #root{position:fixed;inset:0}

  /* Glas-Status-Badge (schwebend, ohne Seiten-Hintergrund) */
  .hud {
    position: fixed;
    right: 22px; top: 22px;
    z-index: 20; pointer-events: none;   /* nicht anklickbar */
  }
  .chip {
    display: inline-flex; align-items: center; gap: 8px;
    padding: 8px 12px; border-radius: 12px;
    background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
    border: 1px solid rgba(255,255,255,.18);
    box-shadow:
      0 8px 30px rgba(0,0,0,.35),
      inset 0 1px 0 rgba(255,255,255,.18),
      inset 0 -1px 0 rgba(255,255,255,.06);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
  }
  .dot {
    width: 8px; height: 8px; border-radius: 50%;
    background: #9fb5ff; box-shadow: 0 0 12px currentColor;
  }
  .state {
    font: 700 12px/1.1 ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;
    letter-spacing: .18em; color: #ffffff;
    text-shadow:
      0 1px 0 rgba(255,255,255,.25),
      0 -1px 0 rgba(0,0,0,.25),
      0 10px 24px rgba(0,0,0,.35);
    text-transform: uppercase;
    white-space: nowrap;
  }
  /* Farb-Varianten für den Punkt je nach Zustand */
  .idle      { color:#cfd8e3; }
  .listening { color:#34d399; }
  .thinking  { color:#a78bfa; }
  .speaking  { color:#60a5fa; }
</style>
</head>
<body>
  <div id="root"></div>

  <!-- HUD (Status-Panel) -->
  <div class="hud">
    <div id="chip" class="chip idle">
      <span class="dot"></span>
      <span id="stateLabel" class="state">IDLE</span>
    </div>
  </div>

  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script>
  (()=>{
    // ---------- Renderer & Scene (volltransparent) ----------
    const root = document.getElementById('root');
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(devicePixelRatio,2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setClearColor(0x000000, 0);     // <— wichtig: kein Hintergrund
    renderer.setClearAlpha(0);               // <— Alpha 0
    root.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 50);
    camera.position.set(0,0,3.2);

    scene.add(new THREE.AmbientLight(0xffffff, .9));
    const dir = new THREE.DirectionalLight(0xffffff, .35);
    dir.position.set(3,2,3); scene.add(dir);

    // ---------- Inner Effect Sphere ----------
    const R_INNER = 0.85; // ~1 cm Abstand zur Glaswand (R=1.0)
    const geoInner = new THREE.SphereGeometry(R_INNER, 192, 128);

    const uniforms = {
      uTime:    { value: 0 },
      uBaseAmp: { value: 0.06 },
      uAudioAmp:{ value: 0.22 },
      uLevel:   { value: 0.0 },
      uBand:    { value: 0.0 },
      uGlow:    { value: 0.85 },
      uColorA:  { value: new THREE.Vector3(200/360, .90, .55) }, // cyan
      uColorB:  { value: new THREE.Vector3(270/360, .85, .60) }, // violet
      uColorC:  { value: new THREE.Vector3(320/360, .85, .62) }, // magenta
      uAspect:  { value: innerWidth/innerHeight }
    };

    const simplex=`
    vec3 mod289(vec3 x){return x - floor(x * (1.0/289.0)) * 289.0;}
    vec4 mod289(vec4 x){return x - floor(x * (1.0/289.0)) * 289.0;}
    vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}
    vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
    float snoise(vec3 v){
      const vec2 C = vec2(1.0/6.0, 1.0/3.0);
      const vec4 D = vec4(0.0,0.5,1.0,2.0);
      vec3 i=floor(v+dot(v,C.yyy));
      vec3 x0=v-i+dot(i,C.xxx);
      vec3 g=step(x0.yzx,x0.xyz); vec3 l=1.0-g;
      vec3 i1=min(g.xyz,l.zxy), i2=max(g.xyz,l.zxy);
      vec3 x1=x0-i1+C.xxx, x2=x0-i2+C.yyy, x3=x0-D.yyy;
      i=mod289(i);
      vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));
      float n_=0.142857142857; vec3 ns=n_*D.wyz-D.xzx;
      vec4 j=p-49.0*floor(p*ns.z*ns.z); vec4 x_=floor(j*ns.z); vec4 y_=floor(j-7.0*x_);
      vec4 x=x_*ns.x+ns.yyyy, y=y_*ns.x+ns.yyyy, h=1.0-abs(x)-abs(y);
      vec4 b0=vec4(x.xy,y.xy), b1=vec4(x.zw,y.zw);
      vec4 s0=floor(b0)*2.0+1.0, s1=floor(b1)*2.0+1.0; vec4 sh=-step(h,vec4(0.0));
      vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy, a1=b1.xzyw+s1.xzyw*sh.zzww;
      vec3 p0=vec3(a0.xy,h.x), vec3 p1=vec3(a1.xy,h.y), vec3 p2=vec3(a0.zw,h.z), vec3 p3=vec3(a1.zw,h.w);
      vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));
      p0*=norm.x; p1*=norm.y; p2*=norm.z; p3*=norm.w;
      vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0); m*=m;
      return 42.0*dot(m*m, vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));
    }`;

    const vInner=`
      uniform float uTime,uBaseAmp,uAudioAmp,uLevel,uBand;
      varying vec3 vPos; varying float vDef;
      ${simplex}
      void main(){
        vec3 p=position;
        float t=uTime*0.35;
        float n1=snoise(normal*1.4+vec3(t*0.6,t*0.4,t*0.8));
        float n2=snoise(position*0.8+vec3(-t*0.3,t*0.5,-t*0.2));
        float d=uBaseAmp*n1 + uAudioAmp*(0.6*uLevel+0.4*uBand)*n2;
        vDef=d; vec3 q=normalize(p)*(1.0+d);
        vPos=q; gl_Position=projectionMatrix*modelViewMatrix*vec4(q,1.0);
      }`;

    const fInner=`
      precision highp float;
      varying vec3 vPos; varying float vDef;
      uniform float uGlow,uTime,uLevel,uBand,uAspect;
      uniform vec3 uColorA,uColorB,uColorC;
      vec3 hsl2rgb(vec3 hsl){
        float h=hsl.x,s=hsl.y,l=hsl.z;
        float c=(1.0-abs(2.0*l-1.0))*s;
        float x=c*(1.0-abs(mod(h*6.0,2.0)-1.0));
        float m=l-0.5*c; vec3 rgb;
        if(h<1.0/6.0) rgb=vec3(c,x,0.0);
        else if(h<2.0/6.0) rgb=vec3(x,c,0.0);
        else if(h<3.0/6.0) rgb=vec3(0.0,c,x);
        else if(h<4.0/6.0) rgb=vec3(0.0,x,c);
        else if(h<5.0/6.0) rgb=vec3(x,0.0,c);
        else rgb=vec3(c,0.0,x);
        return rgb+m;
      }
      void main(){
        vec3 n=normalize(vPos);
        float a=atan(n.y,n.x);
        float mixAB=(sin(a*2.0+uTime*0.7)*0.5+0.5);
        vec3 colA=hsl2rgb(uColorA), colB=hsl2rgb(uColorB), colC=hsl2rgb(uColorC);
        vec3 base=mix(colA,colB,mixAB);
        float pull=clamp(0.25+0.75*(0.6*uLevel+0.4*uBand),0.0,1.0);
        vec3 color=mix(base,colC,pull);
        float sheen=smoothstep(0.0,0.2,vDef+0.1);
        color=mix(color,vec3(1.0),sheen*0.25);
        float fres=pow(1.0-abs(n.z),2.6);
        vec3 glow=color*uGlow*fres;
        gl_FragColor=vec4(color+glow*0.55,0.96);
      }`;

    const innerMat = new THREE.ShaderMaterial({
      uniforms, vertexShader:vInner, fragmentShader:fInner, transparent:true
    });
    const innerSphere = new THREE.Mesh(geoInner, innerMat);
    scene.add(innerSphere);

    // ---------- Glas-Hülle ----------
    const geoGlass = new THREE.SphereGeometry(1.0, 128, 96);
    const glassMat = new THREE.ShaderMaterial({
      transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
      uniforms:{ uTint:{value:new THREE.Color(0xEAF2FF)}, uStrength:{value:0.22} },
      vertexShader:`varying vec3 vN; varying vec3 vV;
        void main(){ vec4 mv=modelViewMatrix*vec4(position,1.0);
          vV=-mv.xyz; vN=normalize(normalMatrix*normal); gl_Position=projectionMatrix*mv; }`,
      fragmentShader:`precision highp float; varying vec3 vN; varying vec3 vV;
        uniform vec3 uTint; uniform float uStrength;
        void main(){
          float fres = pow(1.0 - max(0.0, dot(normalize(vN), normalize(vV))), 2.2);
          vec3 col = uTint * (0.35 + 0.65*fres);
          float a = 0.08 + fres * uStrength;
          gl_FragColor = vec4(col, a);
        }`
    });
    const glass = new THREE.Mesh(geoGlass, glassMat);
    scene.add(glass);

    // ---------- Pulsierender Außenring ----------
    const ringGeo = new THREE.PlaneGeometry(6,6,1,1);
    const ringMat = new THREE.ShaderMaterial({
      transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
      uniforms:{ uTime:{value:0}, uLevel:{value:0} },
      vertexShader:`varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
      fragmentShader:`precision highp float; varying vec2 vUv; uniform float uTime; uniform float uLevel;
        void main(){
          vec2 p = vUv*2.0-1.0;
          float d = length(p);
          float R = 0.78 + 0.015*sin(uTime*2.2) + 0.02*uLevel;
          float width = 0.035 + 0.015*uLevel;
          float ring = smoothstep(R, R-width, abs(d-R));
          float fade = smoothstep(1.1, 0.8, d);
          float a = ring * fade * (0.55 + 0.35*uLevel);
          if(a<=0.001) discard;     /* harte Transparenz, kein Rest-Quadrat */
          gl_FragColor = vec4(vec3(1.0), a);
        }`
    });
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.scale.setScalar(1.18);
    ring.position.z = -0.55;
    scene.add(ring);

    // ---------- State / Level + HUD ----------
    const STYLES = {
      idle:      { glow:.85, base:.06, audio:.22, rotX:.05, rotY:.12, cls:'idle',      label:'IDLE'      },
      listening: { glow:.95, base:.08, audio:.28, rotX:.05, rotY:.16, cls:'listening', label:'LISTENING' },
      thinking:  { glow:.92, base:.07, audio:.24, rotX:.04, rotY:.10, cls:'thinking',  label:'THINKING'  },
      speaking:  { glow:.98, base:.09, audio:.30, rotX:.06, rotY:.20, cls:'speaking',  label:'SPEAKING'  },
    };
    let rotX=.05, rotY=.12, targetLevel=0, currentLevel=0, lastMsg=performance.now();

    const chip = document.getElementById('chip');
    const stateLabel = document.getElementById('stateLabel');

    function setState(s='idle'){
      const m = STYLES[s]||STYLES.idle;
      uniforms.uGlow.value=m.glow;
      uniforms.uBaseAmp.value=m.base;
      uniforms.uAudioAmp.value=m.audio;
      rotX=m.rotX; rotY=m.rotY;
      // HUD anpassen
      chip.className = 'chip ' + m.cls;
      stateLabel.textContent = m.label;
    }
    function setLevel(v=0){ targetLevel=Math.max(0,Math.min(1,Number(v)||0)); lastMsg=performance.now(); }

    // ---------- Loop ----------
    let tPrev = performance.now()/1000;
    const nobreath = new URLSearchParams(location.search).get('nobreath')==='1';

    function frame(){
      requestAnimationFrame(frame);
      const tNow=performance.now()/1000, dt=Math.min(tNow-tPrev,.05); tPrev=tNow;

      const since = performance.now()-lastMsg;
      const fallback = (!nobreath && since>3000) ? (Math.sin(tNow*1.6)*.5+.5)*.35 : targetLevel;
      currentLevel = currentLevel*0.85 + fallback*0.15;

      uniforms.uLevel.value=currentLevel;
      uniforms.uTime.value += dt;
      ringMat.uniforms.uTime.value += dt;
      ringMat.uniforms.uLevel.value = currentLevel;

      innerSphere.rotation.y += rotY*dt;
      innerSphere.rotation.x += rotX*dt;

      ring.lookAt(camera.position);
      renderer.render(scene,camera);
    }
    frame();

    // ---------- Resize ----------
    addEventListener('resize', ()=>{
      renderer.setSize(innerWidth,innerHeight);
      camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
      uniforms.uAspect.value=innerWidth/innerHeight;
    });

    // ---------- Messaging ----------
    addEventListener('message', (ev)=>{
      const d=ev?.data||{};
      if(d.type==='avatar:set')   setState(d.state||'idle');
      if(d.type==='avatar:level') setLevel(d.value);
      if(d.type==='ping') ev.source?.postMessage?.({type:'avatar:ready'}, '*');
    });

    setState('idle'); setLevel(0);
    setTimeout(()=> parent?.postMessage?.({type:'avatar:ready'}, '*'), 40);
  })();
  </script>
</body>
</html>
