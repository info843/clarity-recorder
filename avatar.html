<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Clarity Glass Orb Avatar</title>
<style>
  html,body{margin:0;height:100%;background:transparent;overflow:hidden}
  #root{position:fixed;inset:0}
</style>
</head>
<body>
<div id="root"></div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
(()=>{
// ---------- Setup ----------
const root = document.getElementById('root');
const renderer = new THREE.WebGLRenderer({
  antialias:true,
  alpha:true,                       // Canvas mit Alpha
  powerPreference:'high-performance'
});
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
// FIX: Canvas wirklich transparent machen
renderer.setClearColor(0x000000, 0); // <— wichtig
renderer.setClearAlpha(0);           // <— sicherheitshalber
renderer.domElement.style.background = 'transparent'; // <— CSS-Schutz
root.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 50);
camera.position.set(0,0,3.2);

scene.add(new THREE.AmbientLight(0xffffff, .9));
const dir = new THREE.DirectionalLight(0xffffff, .35); dir.position.set(3,2,3); scene.add(dir);

// ---------- Inner Effect Sphere ----------
const R_INNER = 0.85;
const geoInner = new THREE.SphereGeometry(R_INNER, 192, 128);

const uniforms = {
  uTime:{value:0}, uBaseAmp:{value:0.06}, uAudioAmp:{value:0.22},
  uLevel:{value:0.0}, uBand:{value:0.0}, uGlow:{value:0.85},
  uColorA:{value:new THREE.Vector3(200/360,.90,.55)},
  uColorB:{value:new THREE.Vector3(270/360,.85,.60)},
  uColorC:{value:new THREE.Vector3(320/360,.85,.62)},
  uAspect:{value:innerWidth/innerHeight}
};

const simplex=`...`; // (deiner unverändert)

const vInner=`...`;  // (deiner unverändert)
const fInner=`...`;  // (deiner unverändert)

const innerMat = new THREE.ShaderMaterial({
  uniforms, vertexShader:vInner, fragmentShader:fInner, transparent:true
});
const innerSphere = new THREE.Mesh(geoInner, innerMat);
scene.add(innerSphere);

// ---------- Glass Shell ----------
const R_GLASS = 1.0;
const geoGlass = new THREE.SphereGeometry(R_GLASS, 128, 96);
const glassMat = new THREE.ShaderMaterial({
  transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
  uniforms:{ uTime:{value:0.0}, uTint:{value:new THREE.Color(0xEAF2FF)}, uStrength:{value:0.22} },
  vertexShader:`varying vec3 vN; varying vec3 vV; void main(){ vec4 mv=modelViewMatrix*vec4(position,1.0); vV=-mv.xyz; vN=normalize(normalMatrix*normal); gl_Position=projectionMatrix*mv; }`,
  fragmentShader:`precision highp float; varying vec3 vN; varying vec3 vV; uniform vec3 uTint; uniform float uStrength;
    void main(){ float fres=pow(1.0 - max(0.0, dot(normalize(vN), normalize(vV))), 2.2);
      vec3 col=uTint*(0.35+0.65*fres); float a=0.08+fres*uStrength; gl_FragColor=vec4(col,a); }`
});
const glass = new THREE.Mesh(geoGlass, glassMat);
scene.add(glass);

// ---------- Outer Pulse Ring ----------
const RING_SCALE = 1.18;
const ringGeo = new THREE.PlaneGeometry(6,6,1,1);
const ringMat = new THREE.ShaderMaterial({
  transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
  uniforms:{ uTime:{value:0}, uLevel:{value:0} },
  vertexShader:`varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
  fragmentShader:`precision highp float; varying vec2 vUv; uniform float uTime; uniform float uLevel;
    void main(){
      vec2 p = vUv*2.0-1.0;
      float d = length(p);
      float R = 0.78 + 0.015*sin(uTime*2.2) + 0.02*uLevel;
      float width = 0.035 + 0.015*uLevel;
      float ring = smoothstep(R, R-width, abs(d-R));
      // leichtes Außen-Fade (Korrektur der Reihenfolge)
      float fade = 1.0 - smoothstep(0.8, 1.1, d);
      float a = ring * fade * (0.55 + 0.35*uLevel);
      // FIX: Fragmente ohne sichtbaren Beitrag verwerfen -> kein Rechteck
      if(a <= 0.001) discard;
      gl_FragColor = vec4(vec3(1.0), a);
    }`
});
const ring = new THREE.Mesh(ringGeo, ringMat);
ring.scale.setScalar(RING_SCALE);
ring.position.z = -0.55;
scene.add(ring);

// ---------- State/Level API ----------
const STYLES = {
  idle:{glow:.85,base:.06,audio:.22,rotX:.05,rotY:.12},
  listening:{glow:.95,base:.08,audio:.28,rotX:.05,rotY:.16},
  thinking:{glow:.92,base:.07,audio:.24,rotX:.04,rotY:.10},
  speaking:{glow:.98,base:.09,audio:.30,rotX:.06,rotY:.20},
};
let rotX=.05, rotY=.12, targetLevel=0, currentLevel=0, lastMsg=performance.now();
function setState(s='idle'){ const m=STYLES[s]||STYLES.idle; uniforms.uGlow.value=m.glow; uniforms.uBaseAmp.value=m.base; uniforms.uAudioAmp.value=m.audio; rotX=m.rotX; rotY=m.rotY; }
function setLevel(v=0){ targetLevel=Math.max(0,Math.min(1,Number(v)||0)); lastMsg=performance.now(); }

// ---------- Loop ----------
let tPrev = performance.now()/1000;
const nobreath = new URLSearchParams(location.search).get('nobreath')==='1';
function frame(){
  requestAnimationFrame(frame);
  const tNow=performance.now()/1000, dt=Math.min(tNow-tPrev,.05); tPrev=tNow;
  const since = performance.now()-lastMsg;
  const fallback = (!nobreath && since>3000) ? (Math.sin(tNow*1.6)*.5+.5)*.35 : targetLevel;
  currentLevel = currentLevel*0.85 + fallback*0.15;
  uniforms.uLevel.value=currentLevel;
  uniforms.uTime.value += dt;
  ringMat.uniforms.uTime.value += dt;
  ringMat.uniforms.uLevel.value = currentLevel;
  innerSphere.rotation.y += rotY*dt;
  innerSphere.rotation.x += rotX*dt;
  ring.lookAt(camera.position);
  renderer.render(scene,camera);
}
frame();

// ---------- Resize ----------
addEventListener('resize', ()=>{
  renderer.setSize(innerWidth,innerHeight);
  camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
  uniforms.uAspect.value=innerWidth/innerHeight;
});

// ---------- Messaging ----------
addEventListener('message', (ev)=>{
  const d=ev?.data||{};
  if(d.type==='avatar:set')   setState(d.state||'idle');
  if(d.type==='avatar:level') setLevel(d.value);
  if(d.type==='ping') ev.source?.postMessage?.({type:'avatar:ready'}, '*');
});
setState('idle'); setLevel(0);
setTimeout(()=> parent?.postMessage?.({type:'avatar:ready'}, '*'), 40);
})();
</script>
</body>
</html>
