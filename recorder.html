<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Clarity Interview Recorder</title>
<style>
  html,body{height:100%}
  /* ✨ komplett transparent */
  body{
    margin:0;
    background:transparent;
    color:#eaf2ff;
    font:15px/1.4 ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;
    display:grid; place-items:center;
  }

  .wrap{display:grid; gap:14px; justify-items:center}
  .controls{display:flex; gap:10px; align-items:center}

  /* runde, schwebende Buttons */
  .btn{
    --bg1:#1f9cf0; --bg2:#0ea5e9;
    appearance:none; outline:none; border:0; cursor:pointer;
    color:#fff; font-weight:700; letter-spacing:.2px;
    padding:12px 18px; border-radius:999px;
    background:linear-gradient(180deg,var(--bg1),var(--bg2));
    box-shadow:0 10px 24px rgba(2,12,24,.35);
    transition:.2s transform ease, .2s filter ease, .2s opacity ease;
  }
  .btn:hover{transform:translateY(-1px); filter:brightness(1.03)}
  .btn:active{transform:translateY(0)}
  .btn[disabled]{opacity:.5; cursor:not-allowed}

  .btn--red{--bg1:#ef4444;--bg2:#dc2626}
  .btn--green{--bg1:#22c55e;--bg2:#16a34a}

  .status{font-size:13px; opacity:.9}
  .ok{color:#22c55e} .warn{color:#f59e0b} .err{color:#ef4444}

  /* Medien schweben ohne Rahmen */
  .view{width:min(720px,92vw); display:grid; gap:8px; justify-items:center}
  video{width:100%; height:auto; background:#000; border-radius:14px}
  audio{width:100%}
</style>
</head>
<body>
  <div class="wrap">
    <div class="controls">
      <button class="btn" id="btnStart">Start</button>
      <button class="btn btn--red" id="btnStop" disabled>Stop</button>
      <button class="btn btn--green" id="btnUpload" disabled>Upload</button>
    </div>
    <div class="status" id="status">Ready.</div>
    <div class="view">
      <video id="video" playsinline muted></video>
      <audio id="audio" controls style="display:none"></audio>
    </div>
  </div>

<script>
(function(){
  const $=(s)=>document.querySelector(s);
  const btnStart=$('#btnStart'), btnStop=$('#btnStop'), btnUpload=$('#btnUpload');
  const statusEl=$('#status'); const v=$('#video'), a=$('#audio');

  // API base bleibt wie bei dir
  const params   = new URLSearchParams(location.search);
  const API_BASE = params.get('api') || window.location.origin;

  let mode='video', uid='', companyId='', lang='de', maxSeconds=0;
  let stream=null, rec=null, chunks=[], startedAt=0, lastBlob=null, timer=null, lastUploadId=null;

  function say(m, cls){ statusEl.textContent=m; statusEl.className='status '+(cls||''); }
  function post(type, payload){ parent?.postMessage?.(Object.assign({type},payload||{}),'*'); }
  function stopTimer(){ if(timer){clearInterval(timer); timer=null;} }
  const fmt=(ms)=>{ const s=Math.floor(ms/1000); const mm=String(Math.floor(s/60)).padStart(2,'0'); const ss=String(s%60).padStart(2,'0'); return `${mm}:${ss}`; };

  async function startRecording(){
    try{
      say('Zugriff auf Kamera/Mikro …');
      const cons = (mode==='video')
        ? { audio:{echoCancellation:true,noiseSuppression:true}, video:{width:{ideal:1280},height:{ideal:720}} }
        : { audio:{echoCancellation:true,noiseSuppression:true}, video:false };
      stream = await navigator.mediaDevices.getUserMedia(cons);

      if(mode==='video'){ v.srcObject=stream; v.muted=true; v.style.display='block'; a.style.display='none'; await v.play().catch(()=>{}); }
      else{ v.style.display='none'; a.style.display='block'; }

      chunks=[]; lastBlob=null;
      const mrType = (mode==='video')
        ? (MediaRecorder.isTypeSupported('video/webm;codecs=vp9,opus')?'video/webm;codecs=vp9,opus':(MediaRecorder.isTypeSupported('video/webm;codecs=vp8,opus')?'video/webm;codecs=vp8,opus':'video/webm'))
        : (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')?'audio/webm;codecs=opus':'audio/webm');
      rec = new MediaRecorder(stream,{ mimeType: mrType });
      rec.ondataavailable=(e)=>{ if(e.data?.size>0) chunks.push(e.data); };
      rec.onstop=handleStop;

      rec.start(250); startedAt=Date.now();
      say('Recording …','ok'); post('recorder:started'); btnStart.disabled=true; btnStop.disabled=false; btnUpload.disabled=true;

      stopTimer();
      if(maxSeconds>0){
        timer=setInterval(()=>{ say(`Recording … ${fmt(Date.now()-startedAt)} / ${maxSeconds}s`,'ok'); if(((Date.now()-startedAt)/1000)>=maxSeconds) stopRecording(); },250);
      }else{
        timer=setInterval(()=>{ say(`Recording … ${fmt(Date.now()-startedAt)}`,'ok'); },250);
      }
    }catch(err){
      say('Zugriff verweigert oder Gerät nicht verfügbar.','err');
      post('recorder:error',{message:String(err?.message||err)});
    }
  }

  async function stopRecording(){
    try{
      stopTimer();
      if(rec && rec.state!=='inactive'){ rec.stop(); }
      if(stream){ stream.getTracks().forEach(t=>t.stop()); }
      btnStop.disabled=true;
      say('Verarbeite …','warn');
    }catch(err){
      say('Stop fehlgeschlagen.','err');
      post('recorder:error',{message:String(err?.message||err)});
    }
  }

  async function handleStop(){
    try{
      lastBlob = new Blob(chunks,{ type:(mode==='video'?'video/webm':'audio/webm') });
      const url = URL.createObjectURL(lastBlob);
      if(mode==='video'){ v.srcObject=null; v.src=url; v.muted=false; v.controls=true; v.play().catch(()=>{}); }
      else { a.src=url; a.load(); }
      say('Bereit zum Upload.','ok'); btnUpload.disabled=false;

      // Auto-Upload (wie gehabt)
      await doMuxUpload();
    }catch(err){
      say('Verarbeitung fehlgeschlagen.','err');
      post('recorder:error',{message:String(err?.message||err)});
    }
  }

  async function readJsonSafe(res){
    const ct=res.headers.get('content-type')||'';
    if(ct.includes('json')) return res.json();
    const t=await res.text(); throw new Error(`Non-JSON (${res.status}): ${t.slice(0,200)}…`);
  }

  async function pollAsset(uploadId, maxMs=90_000){
    const start=Date.now();
    while(Date.now()-start<maxMs){
      await new Promise(r=>setTimeout(r,2500));
      const r=await fetch(`${API_BASE}/api/mux-asset?uploadId=${encodeURIComponent(uploadId)}`);
      const j=await readJsonSafe(r);
      if (j?.assetStatus==='ready' && (j?.playbackId || j?.mp4Url)) return j;
    }
    return null;
  }

  async function doMuxUpload(){
    if(!lastBlob){ say('Nichts zum Hochladen.','warn'); return; }
    try{
      say('Upload vorbereiten …'); btnUpload.disabled=true;

      const r1=await fetch(`${API_BASE}/api/mux-upload`,{
        method:'POST', headers:{'Content-Type':'application/json'},
        body:JSON.stringify({ uid, companyId, mode })
      });
      const j1=await readJsonSafe(r1);
      if(!j1?.uploadUrl) throw new Error(j1?.error || 'No uploadUrl');
      lastUploadId=j1.uploadId||null;

      say('Lade zu Mux hoch …','warn');
      const up=await fetch(j1.uploadUrl,{ method:'PUT', body:lastBlob });
      if(!up.ok) throw new Error(`Upload failed (${up.status})`);

      say('Upload fertig – prüfe Asset …','warn');
      let j2=(await (await fetch(`${API_BASE}/api/mux-asset?uploadId=${encodeURIComponent(lastUploadId)}`)).json());
      if(!(j2?.assetStatus==='ready' && (j2?.playbackId || j2?.mp4Url))){
        const p=await pollAsset(lastUploadId); if(p) j2=p;
      }

      if (j2?.mp4Url) { if(mode==='video'){ v.src=j2.mp4Url; v.controls=true; } else { a.src=j2.mp4Url; a.load(); } }

      say('✅ Upload erfolgreich.','ok');
      post('recorder:finished', {
        durationMs: Date.now()-startedAt,
        size: lastBlob.size,
        uploadUrl: j2?.mp4Url || '',
        mux: { uploadId: lastUploadId, playbackId: j2?.playbackId || null, mp4Url: j2?.mp4Url || null }
      });
    }catch(err){
      console.error('Mux upload error:', err);
      say('Upload-Fehler – Bericht kann trotzdem gebaut werden.','err');
      post('recorder:finished',{
        durationMs: Date.now()-startedAt,
        size: lastBlob.size,
        uploadUrl:'',
        mux:{ uploadId: lastUploadId || null }
      });
    }
  }

  // UI
  btnStart.addEventListener('click', ()=> startRecording());
  btnStop.addEventListener('click',  stopRecording);
  btnUpload.addEventListener('click', doMuxUpload);

  // iFrame-Steuerung wie gehabt
  window.addEventListener('message', (ev)=>{
    const d=ev?.data||{};
    if (d.type==='ping') ev.source?.postMessage?.({ type:'recorder:ready' }, '*');
    if (d.type==='start') {
      mode=(d.mode||'video').toLowerCase();
      uid=d.uid||''; lang=d.lang||'de'; companyId=d.companyId||''; maxSeconds=Number(d.maxSeconds||0);
      startRecording();
    }
    if (d.type==='stop') stopRecording();
  });

  setTimeout(()=> parent?.postMessage?.({ type:'recorder:ready' }, '*'), 40);
})();
</script>
</body>
</html>
