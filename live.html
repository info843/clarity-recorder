<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>NVL Interview – Live</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; font:14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#0b0f17; color:#e9eefb;}
    .wrap { display:grid; grid-template-columns: 420px 1fr; gap:16px; padding:20px; }
    .card { background:#111826; border:1px solid #1c2436; border-radius:12px; padding:16px; }
    .row { display:flex; gap:8px; align-items:center; margin-bottom:10px;}
    label { width:130px; color:#9fb2d9;}
    select,input,button,textarea{ background:#0f1725; color:#e9eefb; border:1px solid #25324a; border-radius:8px; padding:8px;}
    button { cursor:pointer; }
    textarea { width:100%; height:170px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    #status { height:240px; overflow:auto; white-space:pre-wrap; }
    #pegel { height:8px; background:#1c2436; border-radius:6px; position:relative; }
    #pegel > i { position:absolute; left:0; top:0; bottom:0; width:0%; background:#6aa3ff; border-radius:6px; transition:width .08s linear; }
    audio { width:100%; margin-top:8px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="row"><label>Company ID</label><input id="companyId" value="NVL-02"></div>
      <div class="row"><label>Language</label>
        <select id="lang">
          <option value="de" selected>de</option>
          <option value="en">en</option>
        </select></div>
      <div class="row"><label>Voice</label>
        <select id="voice">
          <option>verse</option>
          <option selected>alloy</option>
          <option>ash</option>
          <option>ballad</option>
          <option>coral</option>
          <option>echo</option>
          <option>sage</option>
          <option>shimmer</option>
          <option>marin</option>
          <option>cedar</option>
        </select></div>
      <div class="row"><label>Token Endpoint</label><input id="tokenUrl" value="/api/wix-token-proxy"></div>
      <div class="row"><label>Alt Token (Wix)</label><input id="tokenUrl2" value="/_functions/realtimeToken"></div>
      <div class="row"><label>Output Device</label><select id="sink"></select></div>
      <div class="row">
        <button id="btnStart">Start Live</button>
        <button id="btnStop">Stop</button>
        <button id="btnTest">Testton</button>
      </div>
      <div class="row"><label>Remote Pegel</label><div id="pegel"><i></i></div></div>
      <audio id="agentAudio" playsinline></audio>
      <div class="mono" id="status"></div>
    </div>

    <div class="card">
      <h3 style="margin:0 0 8px 0;">Agent Text</h3>
      <textarea id="agentText" placeholder="Hier erscheinen Text-Outputs des Agents…"></textarea>
    </div>
  </div>

<script>
(async function(){
  const els = {
    companyId: document.getElementById('companyId'),
    lang:       document.getElementById('lang'),
    voice:      document.getElementById('voice'),
    tokenUrl:   document.getElementById('tokenUrl'),
    tokenUrl2:  document.getElementById('tokenUrl2'),
    sink:       document.getElementById('sink'),
    btnStart:   document.getElementById('btnStart'),
    btnStop:    document.getElementById('btnStop'),
    btnTest:    document.getElementById('btnTest'),
    audio:      document.getElementById('agentAudio'),
    agentText:  document.getElementById('agentText'),
    status:     document.getElementById('status'),
    pegelBar:   document.querySelector('#pegel > i')
  };

  const log = (...a) => { 
    const line = a.map(x => (typeof x === 'string' ? x : JSON.stringify(x))).join(' ');
    els.status.textContent += (els.status.textContent ? '\n' : '') + line;
    els.status.scrollTop = els.status.scrollHeight;
    console.log(...a);
  };

  async function refreshSinks(){
    try{
      if (!navigator.mediaDevices?.enumerateDevices) return;
      const list = await navigator.mediaDevices.enumerateDevices();
      els.sink.innerHTML = '';
      const outs = list.filter(d=>d.kind==='audiooutput');
      outs.forEach(d=>{
        const o = document.createElement('option');
        o.value = d.deviceId; o.textContent = d.label || ('Output ' + d.deviceId);
        els.sink.appendChild(o);
      });
    }catch(e){ log('sink enumerate error:', e.message); }
  }
  await refreshSinks();

  els.btnTest.onclick = async () => {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const o = ctx.createOscillator();
    o.frequency.value = 880;
    const g = ctx.createGain(); g.gain.value = 0.1;
    o.connect(g).connect(ctx.destination);
    o.start();
    setTimeout(()=>{ o.stop(); ctx.close(); }, 700);
  };

  let pc, dc, micStream, meterTimer;
  let sessionIsReady = false;

  els.btnStart.onclick = async () => {
    try {
      els.status.textContent = '';
      log('[10:20] Start Live');

      const token = await fetchToken();
      if (!token) return;

      pc = new RTCPeerConnection({iceServers: [{urls:'stun:stun.l.google.com:19302'}]});

      // Remote audio -> HTMLAudioElement
      pc.ontrack = (ev) => {
        if (ev.track.kind === 'audio') {
          const s = ev.streams[0];
          els.audio.srcObject = s;
          els.audio.muted = false;
          els.audio.volume = 1.0;
          els.audio.play().catch(e => log('audio play error', e.message));
          const at = s.getAudioTracks()[0];
          log('[live] remote track flags: muted=', at.muted, 'enabled=', at.enabled, 'state=', at.readyState);
          clearInterval(meterTimer);
          meterTimer = setInterval(()=> {
            const t = s.getAudioTracks()[0];
            if (!t) return;
            const w = (t.muted || t.readyState!=='live') ? 0 : 95;
            els.pegelBar.style.width = w + '%';
          }, 120);
        }
      };

      // Mic holen und hinzufügen – **ohne** extra recvonly-Transceiver
      micStream = await navigator.mediaDevices.getUserMedia({audio:true, video:false});
      const micTrack = micStream.getAudioTracks()[0];
      const sender = pc.addTrack(micTrack, micStream);

      // ERZINGE sendrecv (einzige m=audio Line)
      if (sender?.transceiver) {
        sender.transceiver.direction = 'sendrecv';
      }

      // DataChannel
      dc = pc.createDataChannel('oai-events');
      dc.onopen = onDataChannelOpen;
      dc.onmessage = onAgentEvent;

      // SDP Offer
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);

      const base = 'https://api.openai.com/v1/realtime';
      const model = 'gpt-4o-realtime-preview-2025-09-12';
      const sdpRes = await fetch(`${base}?model=${model}`, {
        method:'POST',
        body:offer.sdp,
        headers:{
          Authorization: `Bearer ${token}`,
          'Content-Type': 'application/sdp',
          'OpenAI-Beta': 'realtime=v1'
        }
      });

      if(!sdpRes.ok){
        log('SDP upstream error', sdpRes.status, await sdpRes.text());
        return;
      }
      const answer = { type:'answer', sdp: await sdpRes.text() };
      await pc.setRemoteDescription(answer);
      log('pc: connected (SDP answer set)');

      els.sink.onchange = async () => {
        const id = els.sink.value;
        if (els.audio.setSinkId) {
          try { await els.audio.setSinkId(id); log('Output device set:', id || 'default'); }
          catch (e) { log('setSinkId error:', e.message); }
        }
      };
    } catch (e) {
      log('start error:', e.message);
    }
  };

  els.btnStop.onclick = () => {
    try {
      dc && dc.close();
      pc && pc.close();
      micStream && micStream.getTracks().forEach(t=>t.stop());
      clearInterval(meterTimer);
      els.pegelBar.style.width = '0%';
      sessionIsReady = false;
      log('stopped');
    } catch {}
  };

  async function fetchToken(){
    const payload = {
      companyId: els.companyId.value.trim(),
      lang: els.lang.value,
      voice: els.voice.value
    };
    log('Token endpoint:', els.tokenUrl.value);
    try{
      const r = await fetch(els.tokenUrl.value, {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)});
      const j = await r.json();
      log('Token response (proxy) status:', r.status, 'body:', j);
      if (r.ok && j?.ok && j?.token) return j.token;
    }catch(e){ log('proxy fetch error', e.message); }
    try{
      const r2 = await fetch(els.tokenUrl2.value, {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)});
      const j2 = await r2.json();
      log('Token response (Wix) status:', r2.status, 'body:', j2);
      if (r2.ok && j2?.ok && j2?.token) return j2.token;
    }catch(e){ log('wix fetch error', e.message); }
    log('startLive error: token fallback failed');
    return null;
  }

  /* ---------- DataChannel events ---------- */
  function onDataChannelOpen(){
    log('DataChannel open');

    // 1) Session minimal setzen
    const sess = {
      voice: els.voice.value || 'alloy',
      modalities: ['audio', 'text']
    };
    dc.send(JSON.stringify({ type: 'session.update', session: sess }));
    log('[rt] session.update sent', sess);

    // 2) response.create NICHT sofort senden – wir warten auf session.created
    //    (siehe onAgentEvent)
  }

  function onAgentEvent(ev){
    // Roh-Log kurz (max 200 Zeichen), hilft bei Debug
    try {
      const raw = typeof ev.data === 'string' ? ev.data : '';
      if (raw) log('[rt] event', raw.slice(0, 200));
      const msg = JSON.parse(ev.data);

      if (msg?.type === 'error') {
        log('[rt] ERROR payload:', JSON.stringify(msg));
      }

      if (msg?.type === 'session.created') {
        sessionIsReady = true;
        // Jetzt erst Begrüßung anfordern (sicheres Mapping auf m=audio)
        dc.send(JSON.stringify({
          type:'response.create',
          response:{
            modalities:['audio','text'],
            instructions:'Sage bitte exakt TESTTEST und zähle dann laut eins zwei drei.',
            voice: els.voice.value || 'alloy'
          }
        }));
        log('[rt] response.create (nach session.created) sent');
      }

      if (msg?.type === 'response.output_text.delta' && msg?.delta) {
        els.agentText.value += msg.delta;
        els.agentText.scrollTop = els.agentText.scrollHeight;
      }
      if (msg?.type === 'response.delta' && msg?.delta) {
        els.agentText.value += msg.delta;
        els.agentText.scrollTop = els.agentText.scrollHeight;
      }
      if (msg?.type === 'response.completed') {
        els.agentText.value += '\n';
      }
    } catch {
      // non-JSON ignorieren
    }
  }
})();
</script>
</body>
</html>
